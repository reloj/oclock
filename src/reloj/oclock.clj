(ns reloj.oclock
  (:refer-clojure :exclude [==]) ; Explicit exclusion for core.logic
  (:require [clojure.core.logic :refer :all]
            [clojure.math.combinatorics]
            [clojure.set]))


;; Design approach #1: relational spirit, without caring for what if or when would return.

(defmacro oif
  "A relational if. It transforms:
      (oif (membero q [1 2])
           (== r 3)
           (!= r 3))
  into:
      (conda [(membero q [1 2])
              (== r 3)]
             [(!= r 3)])
  echoing a procedural if."
  [if then else]
  `(conda
    [~if ~then]
    [~else]))

(defmacro owhen [if then]
  "Relational when. If condition is met new relation is required. If not, it succeeds (a->b is true when a is false)"
  `(oif ~if ~then succeed))

;; Design approach #2: strict rule of procedural result being first relational parameter. Less "relational-native" but helps with code transcription.

(defn o= [o a b]
  (conde [(== o true)
          (== a b)]
         [(== o false)
          (!= a b)]))

(defn oif [res cond if else]
  "Note that side effects that are short-circuited in 'else' statements when true is not
   something that really makes sense in a relational oif."
  (conde [(nafc membero cond [nil false])
          (== res if)]
         [(membero cond [nil false])
          (== res else)]))

(defn owhen [res cond if]
  (oif res cond if nil))

(comment
  (run* [r] (oif r true 1 2))
  (run* [x] (fresh [q] (oif 1 q 1 2) (o= q 4 x)))
  (run* [x] (fresh [q] (oif 2 q 1 2) (o= q 4 x)))

  (run* [q x y z]
    (with-orels q [o= oif] ; q is used for all base rels; fresh lvars are created for things in place
      (oif false y z)
      (oif (o= 1 x)
           4 x))))

(comment
  (defn ocount [])

  (defn oor []) ; with short circuiting? does it make sense?
  (defn oand [])

  (defn ofn []) ; iterate over simplest-to-more complex trees of all whitelisted non-side-effect clojure.core functions. look into re-find
  (defn omap [])
  (defn olet [])
  (defn oapply [])

  (defn ocond [])

  (defn oassoc []) ; featureo omerge
  (defn oassoc-in [])
  (defn oconj [])
  (defn oget [])
  (defn oget-in [])

  (defn o-> [])
  (defn o->> []))


(defn ocoll? [elts]
  "A relational coll? - a collection is composed of things."
  (fresh [x]
    (membero x elts)))

(defn oset? [elts]
  "Pending: How to determine this is closed."
  succeed)

(defne any-placeo
  "A generalization of membero and rembero, and, backwards, a 'random-popo'."
  [x l o]
  ([_ _ [x . l]])
  ([_ [l1 . ls] [l1 . os]]
   (any-placeo x ls os)))

(run* [p q] (any-placeo p q [1 2 3]))

(defn not-emptyo [coll]
  (fresh [elt rest]
    (conso elt rest coll)))

(defne set==
  "Unification of 2 colls as if they were sets"
  [seta setb]
  ([[] []])
  ([_ _]
   (fresh [elt a b]
     (any-placeo elt a seta)
     (any-placeo elt b setb)
     (set== a b))))

(run* [q] (set== [1 2][2 q])) ; TODO esto devuelve duplicados
(run* [q] (set== [1][q]))

(run* [p q] (conso p q {:a 1})) ; WRONG conso only works on ordered colls, maps are unordered colls
(run* [p q] (conso p q #{2 1})) ; WRONG conso only works on ordered colls, sets are unordered colls

(def kv== set==)

(run* [q] (kv== {:a 1} q))
(run* [q] (kv== {:a 1 :b 2 :c 3} {:a 1 :b 2 q 3}))

(defn -same-kvs [a b]
  (clojure.set/intersection (set a) (set b)))

(defn -devec-map [vecced-map]
  (apply hash-map (flatten vecced-map)))

(defn -either-list [len]
  "Generates all possible lists of length len with 'either vectors'
   (vectors of 2 booleans where or is true)"
  (let [pos [[true false] [true true] [false true]]]
    (if (= len 1)
      (map vector pos)
      (for [elt (-either-list (dec len))
            new pos]
        (conj elt new)))))

(defn -key-and-lvar-map [pos keyvec]
  "Receives a possibility generated by -either-list, and generates a
   pair of lvared maps with it. (-either-list is used to ensure that keys
   are present in either of the two maps, so the merge produces each target
   key, but until this function they are not proper maps)"
  (apply mapv (comp #(zipmap keyvec %)
                    #(map (fn [x] (when x (lvar))) %)
                    vector)
         pos))

(defn -lvar-map-size-x [x]
  (apply hash-map (repeatedly (* 2 x) lvar)))

(defn unify-sets [a b]
  (let [int (clojure.set/intersection a b) ; this only works with reified sets, not lvars
        ua (clojure.set/difference a int) ; TODO deprecate when unify-with-set works
        ub (clojure.set/difference b int)]
    (if (= (count ua) (count ub))
       (or* (map #(== (vec ua) %)
                 (clojure.math.combinatorics/permutations ub)))
       fail)))

(comment
  (run* [q] (unify-sets #{1 2} #{q 2})))

;(defn unground-map [m]
;  (or* (map #(== m (-lvar-map-size-x %))
;            (range))))

(defn omerge
  "Relates the merged map ab as the union of a and b.
   As in merge, b can override values in a for the same key."
  [ab a b]
  (cond
   ; if any dict is grounded to {} problem is easy
   (= {} ab) (== [a b] [{} {}])
   (= {} a) (== ab b)
   (= {} b) (== ab a)
   ; if a and b are grounded, irrespective of ab's status, the answer is easy
   (every? (complement lvar?) [a b])
   (== ab (merge a b)) ; WRONG! merge will not unify 2 keys that are lvars
   ; if only a is not ground: a ~= ab but its vals of same-kvs can be anything, or nothing (not same as nil)
   (every? (complement lvar?) [ab b])
   (let [overlap (-same-kvs ab b)
         opts (map (fn [[k v1]]
                     (let [v (lvar)]
                       [k v (membero v [v1 nil (lvar)])])) ; Error: nil needs to be no key
                   overlap)]
     (all (everyg #(nth % 2) opts)
          (== a (merge ab (-devec-map (map pop opts))))))
   ; if only b is not ground: b ~= ab but its vals of same-kvs can also be nonexisting (not same as nil)
   (every? (complement lvar?) [ab a])
   (let [overlap (-same-kvs ab a)
         opts (map (fn [[k v1]]
                     (let [v (lvar)]
                       [k v (membero v [v1 nil])])) ; Error: nil needs to be no key
                   overlap)]
     (all (everyg #(nth % 2) opts)
          (== b (merge ab (-devec-map (map pop opts))))))
   ; only ab grounded restricts all keys
   (not (lvar? ab))
   (let [ks (keys ab)]
     (or* (map #(all (let [[x y] (-key-and-lvar-map % ks)]
                       (== [a b] [x y]))
                     (unify-sets (set ab) (set [:????]))) ; THIS WAS HALF-WRITTEN!!
               (-either-list (count ks)))))
   ; only b grounded is a strict subset of ab for both keys and vals
   (not (lvar? b))
   ;(all (unground-map a) ; omerge keeps seing an lvar!
   ;     (omerge ab a b))
   (or* (map #(let [m (-lvar-map-size-x %)]
                (all (== m a)
                     (omerge ab m b)))
             (range)))
   ; only a grounded is a strict subset of ab for keys, but any val can be replaced
   (not (lvar? a))
   ;(all (unground-map b) ; omerge keeps seing an lvar!
   ;     (omerge ab a b))
   (or* (map #(let [m (-lvar-map-size-x %)]
                (all (== m b)
                     (omerge ab a m)))
             (range)))
   ; if none are grounded, i need to generate a divergent sequence of growing maps
   :else
   ;(all (unground-map ab) ; omerge keeps seing an lvar!
   ;     (omerge ab a b))
   (or* (map #(let [m (-lvar-map-size-x %)]
                (all (== m ab)
                     (omerge m a b)))
             (range)))))


  ;
;(run 1 [q] (== q (partial-map {:a 1}))
;     (== q (partial-map {:b 1})))
;Error printing return value at clojure.core.logic.LVar/unify_terms (logic.clj:678).
;clojure.core.logic.PMap@3c6f0c28 is non-storable

;; I found a bug!!

;(run 1 [q] (== (partial-map {:a q})
;
;               (partial-map {:a 1 :b 1})))
;=> (1)
;(run 1 [q] (== (partial-map {:a 1})
;
;               (partial-map {:a q :b 1})))
;Error printing return value (IllegalArgumentException) at clojure.lang.RT/seqFrom (RT.java:553).
;Don't know how to create ISeq from: java.lang.Long
